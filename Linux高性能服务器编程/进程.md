# 进程

## 一、定义

**进程**就是**正在内存中运行的程序**，Linux下的一个进程在内存里有三部分的数据，就是**“代码段”， “堆栈段” 和 “数据段”** 

- 代码段：存放程序代码
- 堆栈段：存放程序的返回地址，程序的参数以及程序的局部变量
- 数据段：存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间)

系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的

## 二、查看进程的编号

### 1. 查看进程

- ` ps `查看当前终端的进程
- ` ps -ef ` 查看系统全部的进程
- ` ps -ef | more ` 查看系统全部的进程，结果分页显示（enter下一行，空格翻页)

![1633953742447](img/1633953742447.png)

UID：启动进程的操作系统用户

PID：进程编号（进程标识符)

PPID：进程的父进程的编号

C：CPU使用的资源百分比

STIME：进程启动时间

TTY：进程所属的终端

TIME：使用掉的CPU时间

CMD：执行的指令



### 2. 查看系统中某个运行的进程

```bash
ps -ef | grep xxxx(xxxx是执行的程序名)
```

例如：

```bash
ps -ef | grep nginx
```



### 3. getpid库函数

```C++
pid_t getpid();
```

**作用**：获取本程序运行时进程的编号

函数没有参数，返回值是进程的编号, pid就是 typedef int pid_t

示例：

```cpp
#include<iostream>
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
using namespace std;

int main()
{
    cout << "本进程的进程编号是："<< getpid() << endl;  
    return 0;
}
```

每个进程拥有自己的编号PID，由系统动态分配，动态收回。

相同的程序在不同的时间执行，进程的编号是不同的。

进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，不管任何时间，系统不可能存在两个编号相同的进程

## 三、多进程

#### 1. fork

```C++
pid_t fork();
```

**作用**：用于产生一个新的进程

函数返回值pid_t 是一个整数，**在父进程中，返回值是子进程编号，在子进程中，返回值是0**

示例：

```cpp
#include<iostream>
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
using namespace std;

int main()
{
    cout << "本进程的进程编号是："<< getpid() << endl;  

    int ipid = fork();   // 生成子进程
    sleep(1);            // sleep等待进程的生成
    cout << "pid = " << ipid << endl;

    if(ipid) cout << "父进程编号是：" << getpid() << endl;
    else cout << "生成的子进程编号是：" << getpid() << endl;

    //sleep(30);    // 为了方便查看进程在shell下用ps -ef | grep ./a.out 查看本进程的编号
    return 0;
}
```

结果如下：生成了一个子进程，在父进程中ipid是子进程的编号，在子进程中ipid是0，表示创建成功

![1633956812202](img/1633956812202.png)

fork函数创建了一个新的进程，**它和父进程使用相同的代码段，子进程拷贝了父进程的堆栈段和数据段。**子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。**可以通过fork的返回值来区别父进程和子进程，**然后再执行不同的代码