# C++函数指针和函数类型

## 定义

- **函数指针**指向的是函数而非对象。和其他指针类型一样，函数指针指向某种特定类型。
- **函数类型**由它的返回值和参数类型决定，与函数名无关

```cpp
bool length_compare(const string &, const string &);
```

上述函数类型是：`bool (const string &, const string &)`;

上述函数指针pf：`bool (*pf)(const string &, const string &)`;

## 使用函数指针

- 当把函数名作为一个值使用时，该函数自动的转换成指针，如：

```c++
pf = length_compare <=>等价于pf = &length_compare
```

## 函数指针形参

- **函数类型**不能定义为形参，但是形参可以是指向函数的指针；
- 函数作为实参使用时，会自动的转换成函数指针；

```cpp
typedef bool Func(const string &, const string &) // Func是函数类型；
typedef bool (*FuncP)(const string &, const string &) // FuncP是函数指针类型；
```

```cpp
typedef decltype(length_compare) Func2  // Func2是函数类型；
typedef decltype(length_compare) *Func2P // Func2是函数指针类型；
注意：decltype(length_compare)返回的是函数类型，而不是函数指针类型；    
```

```cpp
using FTtype = int(int,int); //函数类型
typedef int (*pf)(int, int); //函数指针

int func(int a, int b){return a+b;}
void print(int a, int b, FTtype fn){
    // 编译器将其隐式转化成函数指针，因为函数类型不能作为形参
    cout << fn(a,b) << endl;
}

int main()
{
    print(1,2,func);
    cout << typeid(FTtype).name() << endl;  // FiiiE
    cout << typeid(func).name() << endl;    // FiiiE
    cout << typeid(decltype(func)).name() << endl;  // FiiiE
    cout << typeid(pf).name() << endl;  // PFiiiE
    return 0;
}
```

- 下面两个声明语句是同一个函数，因为编译器会自动的将 FTtype 转换成函数指针类型

```cpp
void print(int a, int b, FTtype  fn);
void print(int a, int b, pf fn);
```

## 返回指向函数的指针

返回执行函数类型的指针。和函数参数不同，编译器不会自动地将函数返回类型当作指针类型处理，必须**显示的**将返回类型**指定为指针**，如下

```cpp
using F = int(int*, int);	F是函数类型
using PF = int(*)(int*,int);	PF是函数指针类型
F  f1(int);    //错误： F是函数类型
PF  f1(int);   //正确： PF是函数指针类型
```

# lambda表达式

实际上就是提供一个**类似匿名函数**的特性，而**匿名函数**则是**在需要一个函数，但是又不想费力去命名一个函数的情况下**去使用的，这样的场景其实很多，所以匿名函数几乎是现代编程语言的标配

## Lambda表达式基础

基本语法：

```bash
[捕获列表](参数列表) mutable(可选)异常属性 -> 返回类型{
	// 函数体
}
[caputrue](params) opt -> ret { body; };
```

- Lambda表达式以一对**中括号**开始
- 跟函数定义一样，我们有**参数列表**
- 有函数体，里面会有return 语句
- Lambda表达式一般不需要说明返回值( 相当于auto ); 有特殊情况需要说明时，则应使用箭头语法的方式
- 每个lambda表达式都有一个全局唯一的类型，要精确捕捉lambda表达式到一个变量中，只能通过auto声明的方式

## 基本使用

- 捕获列表
- 参数列表
- 返回类型
- 函数体

```c++
#include<iostream>
#include<algorithm> // 算法库
#include<vector>
using namespace std;

int main()
{
    int c = [](int a, int b)->int{

        return a + b;
    }(1,2);
    std::cout << c << std::endl;

    int d = [](int n){
        return [n](int x){  // 捕获外面的参数n
            return n+x; 
        }(2);
    }(1);
    std::cout << d << std::endl;

    // 函数式编程
    auto adder = [](int n){
        return [n](int x){
            return n+x;
        };
    };

    std::cout << adder(1)(2) << std::endl;
}
运行：g++ -std=c++11 test.cpp
结果：3
     3
     3
```



# 可调用对象

## 定义

- 函数
- 函数指针
- lambda表达式
- bind创建的对象
- 重载了函数调用运算符的类

## 使用

C++11中提供了std::function和std::bind统一了可调用对象的各种操作。

不同类型可能具有相同的调用形式，如：

```cpp
// 普通函数
int add(int a, int b){return a+b;} 

// lambda表达式
auto mod = [](int a, int b){ return a % b;}

// 函数对象类
struct divide{
    int operator()(int denominator, int divisor){
        return denominator/divisor;
    }
};
```

上述三种可调用对象虽然类型不同，但是共享了一种调用形式：

```cpp
int(int ,int)
```

std::function就可以将上述类型保存起来，如下：

```cpp
std::function<int(int ,int)>  a = add; 
std::function<int(int ,int)>  b = mod ; 
std::function<int(int ,int)>  c = divide(); 
```

# std::function对象

## 定义

- std::function 是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。

- 定义格式：std::function<函数类型>

- std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。

## 头文件

> #include<functional>

## 使用

```c++
#include <functional>
#include <iostream>

struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_+i << '\n'; }
    int num_;
};

void print_num(int i)
{
    std::cout << i << '\n';
}

struct PrintNum {
    void operator()(int i) const
    {
        std::cout << i << '\n';
    }
};

int main()
{
    // 存储自由函数
    std::function<void(int)> f_display = print_num;	//将print_num函数指针存储在f_display中
    f_display(-9);

    // 存储 lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();
     
    // 存储到 std::bind 调用的结果
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();
     
    // 存储到成员函数的调用
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;//类成员函数需要加&,因为传入的是指针
    const Foo foo(314159);
    f_add_display(foo, 1);	
    f_add_display(314159, 1);
     
    // 存储到数据成员访问器的调用
    std::function<int(Foo const&)> f_num = &Foo::num_; //存储数据成员
    std::cout << "num_: " << f_num(foo) << '\n';
     
    // 存储到成员函数及对象的调用
    using std::placeholders::_1;
    std::function<void(int)> f_add_display2 = std::bind( &Foo::print_add, foo, _1 );
    f_add_display2(2);
     
    // 存储到成员函数和对象指针的调用
    std::function<void(int)> f_add_display3 = std::bind( &Foo::print_add, &foo, _1 );
    f_add_display3(3);
     
    // 存储到函数对象的调用
    std::function<void(int)> f_display_obj = PrintNum();
    f_display_obj(18);

}
```

输出：

```cpp
-9
42
31337
314160
314160
num_: 314159
314161
314162
18
```

# std::bind

## 定义

它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体.可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表.std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下几个作用：

- 将可调用对象和其参数绑定成一个仿函数
- 只绑定部分参数，减少可调用对象传入的参数
- 改变参数绑定顺序

## 头文件

># include<functional>

## **std::bind绑定普通函数**

```c++
double myDivide(double x, double y)
{
	return x/y;
}
auto fn_half = std::bind(myDivide,1,2);	//绑定成仿函数
std::cout << fn_half() << std::endl;
```

bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (myDivide,1,2)等价于std::bind (&myDivide,1,2)

## **std::bind绑定一个成员函数**

```c++
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};
int main() 
{
    Foo foo;
    auto f = std::bind(&Foo::print_sum, &foo, 95, 5);
    f(); // 100
}
```

第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。必须显示的指定&Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在Foo::print_sum前添加&。使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &foo；

## **std::bind绑定一个引用参数**

默认情况下，bind的那些不是占位符（占位符的概念后面介绍）的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以**引用**的方式传递，或是要绑定参数的类型**无法拷贝**。

```c++
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std::placeholders;
using namespace std;

ostream & print(ostream &os, const string& s, char c)
{
    os << s << c;
    return os;
}

int main()
{
    vector<string> words{"hello", "world", "this", "is", "C++11"};
    ostringstream os;
    char c = ' ';
    for_each(words.begin(), words.end(), 
                   [&os, c](const string & s){os << s << c;} );
    cout << os.str() << endl;

    ostringstream os1;
    // ostream不能拷贝，若希望传递给bind一个对象，
    // 而不拷贝它，就必须使用标准库提供的ref函数
    for_each(words.begin(), words.end(),
                   bind(print, ref(os1), _1, c));
    //ref函数返回一个对象，包含给定的引用，此对象是可以拷贝的。
    cout << os1.str() << endl;

}
```



# 占位符

(std::placeholders      std::is_placeholder       std::is_bind_expression)

一个变量的占位符, 用于函数绑定时使用

定义如下：

```c++
namespace placeholders {
  extern /* unspecified */ _1;
  extern /* unspecified */ _2;
  extern /* unspecified */ _3;
  // ...
}
```

他的应用就是bind绑定参数时的占位符，当调用bind返回的函数对象时，带有占位符_1的参数被调用中的第一个参数替换，_2被调用中的第二个参数替换，依此类推。

## 使用

> using namespace std::placeholders;

# std::list

使用标准的std::list进行容器数据处理时，操作比较底层

List其实相当于**数据结构中的双链表**,List对象提供了两个pointer，分别指向前后元素,List在几个方面与vector和deuqe(单项队列)不同

1.List不支持随机访问，因此访问元素的效率较低；
2.任何位置上，执行元素的插入和移除都很快，始终是常量时间内完成，因为无需移动任何元素；
3.安插和删除的操作不会因此指向其他元素的pointer(指针)、reference(引用)、iterator(迭代器)失效；
4.List对异常的控制是，要么操作成功，要么什么都不发生。

**需要的头文件**

> #include<list>

其中的list类型定义于namespace std 中，是一个class template：

```c++
template<
	class T,
	class Allocator = std::allocator<T>
>class list;
```

List的元素可以是**任何类型T**，Allocator用于**指定内存模型**，默认是C++ 标准库提供的类型。

**List操作**

​		List容器提供的一般STL所具备的通用能力，但相比于vector和deque具有如下不同——
　　1.由于不支持随机访问，所以List没有at函数和下标操作符；
　　2.List并未提供容量、空间重新分配等操作的函数，因为没有必要，每个元素有自己的内存，在元素被删除前一直有效；
　　3.List提供不少特殊成员函数，专门用于移动和移除元素，较之同名的STL通用算法，这些函数执行起来更加迅速，因为他们只需要调整几个pointer即可。

### **构建、复制和销毁(Create、Copy and Destroy)**

| 序号 | 操作                                           |                             效果                             |
| :--: | :--------------------------------------------- | :----------------------------------------------------------: |
|  1   | list<Elem> c                                   |         Default构造函数，产生一个list，没有任何元素          |
|  2   | list<Elem>c(c2)<br/>list<Elem>c=c2             | Copy构造函数，建立c2同型list并成为c2的一份副本，该复制是深度复制 |
|  3   | list<Elem>c(rv)<br/>list<Elem>c=rv             | rv是一个list右值引用，那么这里的构造函数是一个Move构造函数，建立一个新的list，取右值内容（C++11新特性） |
|  4   | list<Elem>c(n)                                 |  利用元素的默认构造函数生成一个大小为n（容量也为n）的vector  |
|  5   | list<Elem>c(n,elem)                            |            建立一个大小为n的list，并初始化为elem             |
|  6   | list<Elem>c(beg,end)                           |   建立一个list，并以迭代器所指向的区间[beg,end）作为元素值   |
|  7   | list<Elem>c(initlist)<br/>list<Elem>c=initlist |   建立一个list，以初值列initlist元素为初值（C++11新特性）    |
|  8   | c.~list()                                      |                    销毁所有元素，释放内存                    |

### **List也提供元素比较、查询大小等操作**

| 序号 | 操作                      | 效果                                               |
| ---- | ------------------------- | -------------------------------------------------- |
| 1    | c.empty()                 | 容器为空返回true，不为空返回false，相当于size()==0 |
| 2    | c.size()                  | 返回当前元素的个数                                 |
| 3    | c.max_size()              | 返回元素个数之最大可能量                           |
| 4    | c1==c2                    | 对每个元素调用c1==c2，全部相等返回true             |
| 5    | c1！=c2                   | 只要有一个元素相等，返回true，相当于!(c1==c2)      |
| 6    | c1>c2,c1>=c2,c1<c2,c1<=c2 | 同上，依次类推                                     |

### 元素访问(Element Access)

与vector和deque不同，list没有at和下标运算符，因此只有两个直接访问元素的函数。或者使用range-based for循环遍历所有元素

| 序号 |   操作    |                      效果                      |
| ---- | :-------: | :--------------------------------------------: |
| 1    | c.front() |   返回第一个元素（不检查是否存在第一个元素）   |
| 2    | c.back()  | 返回最后一个元素（不检查是否存在最后一个元素） |

# shared_ptr(智能指针)

要确保用 new 动态分配的内存空间在程序的各条执行路径都能被释放是一件麻烦的事情。[C++](http://c.biancheng.net/cplus/) 11 模板库的 <memory> 头文件中定义的智能[指针](http://c.biancheng.net/c/80/)，即 shared _ptr 模板，就是用来部分解决这个问题的。

只要将 new 运算符返回的指针 p 交给一个 **shared_ptr 对象“托管”**，就不必担心在哪里写`delete p`语句——实际上根本不需要编写这条语句，托管 p 的 shared_ptr 对象在消亡时会自动执行**delete p**。而且，该 shared_ptr 对象能像指针 p —样使用，即假设托管 p 的 shared_ptr 对象叫作 ptr，那么 *ptr 就是 p 指向的对象。

通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下：

```c++
shared_ptr<T> ptr(new T);  // T 可以是 int、char、类等各种类型，用ptr托管指向T的指针
```

此后，ptr 就可以像 T* 类型的指针一样使用，即 *ptr 就是用 new 动态分配的那个对象。

 多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行`delete p`。

例如下面的程序：

```c++
#include <iostream>
#include <memory>
using namespace std;
class A
{
public:
    int i;
    A(int n):i(n) { };
    ~A() { cout << i << " " << "destructed" << endl; }
};
int main()
{
    shared_ptr<A> sp1(new A(2)); //A(2)由sp1托管，
    shared_ptr<A> sp2(sp1);       //A(2)同时交由sp2托管
    shared_ptr<A> sp3;			
    sp3 = sp2;   //A(2)同时交由sp3托管	多个shared_ptr对象托管同一个指针.
    cout << sp1->i << "," << sp2->i <<"," << sp3->i << endl;
    A * p = sp3.get();      // get返回托管的指针，p 指向 A(2)
    cout << p->i << endl;  //输出 2
    sp1.reset(new A(3));    // reset导致托管新的指针, 此时sp1托管A(3)
    sp2.reset(new A(4));    // sp2托管A(4)
    cout << sp1->i << endl; //输出 3
    sp3.reset(new A(5));    // sp3托管A(5),A(2)无人托管，被delete
    cout << "end" << endl;
    return 0;
}
```

输出结果：

```c++
2,2,2
2
3
2 destructed
end
5 destructed
4 destructed
3 destructed
   
```

多个 sharecLptr 对象托管同一个指针。这多个 shared_ptr 对象会共享一个对共同托管的指针的“托管计数”。有 n 个  shared_ptr 对象托管同一个指针 p，则 p 的托管计数就是 n。当一个指针的托管计数减为 0 时，该指针会被释放。shared_ptr 对象消亡或托管了新的指针，都会导致其原托管指针的托管计数减 1。

shared_ptr 的 reset 成员函数可以使得对象解除对原托管指针的托管（如果有的话），并托管新的指针。原指针的托管计数会减 1。

输出的第 4 行说明，用 new 创建的动态对象 A(2) 被释放了。程序中没有写 delete 语句，而 A(2) 被释放，是因为程序的第  23 行执行后，已经没有 shared_ptr 对象托管 A(2)，于是 A(2) 的托管计数变为 0。最后一个解除对 A(2) 托管的  shared_ptr 对象会释放 A(2)。

 main 函数结束时，sp1、sp2、sp3 对象消亡，各自将其托管的指针的托管计数减为 0，并且释放其托管的指针，于是会有以下输出：
 5 destructed
 4 destructed
 3 destructed

**只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。**

注意，不能用下面的方式使得两个 shared_ptr 对象托管同一个指针：

```c++
A* p = new A(10);
shared_ptr <A> sp1(p), sp2(p);
```

sp1 和 sp2 并不会共享同一个对 p 的托管计数，而是各自将对 p 的托管计数都记为 1（sp2 无法知道 p 已经被 sp1 托管过）。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构 p，这会导致程序崩溃。

# 回调函数

回调函数就是一个通过函数指针调用的函数，如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。

# nullptr与NULL

NULL在C的头文件中，通常定义如下：

```c++
#define NULL ((void*)0)
```

但是在C++中，NULL是这样定义的：

```c++
#define NULL 0
```

在C++中，NULL不过也是0罢了

NULL在C++与C中的区别：在C++中不能将void *类型的指针**隐式转换**成其他指针类型

然而nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。

总结：如果你想表示空指针，那么使用nullptr，而不是NULL。

注：nullptr在C++ 11中才出现。

# 异步客户端和同步客户端

## 同步客户端

比如一个连接有两个请求，请求1 和 请求2，请求1 先发起请求，请求2后发起请求

则请求2 要等待请求1 响应完成才能接收到响应。

举个枣子，httpclient 发送get请求，线程会一致阻塞，直到有响应结果。

## 异步客户端

比如一个连接有两个请求，请求1 和 请求2，请求1 先发起请求，请求2后发起请求，请求1 和 请求2 可以并发的获取响应。

举个枣子，asynhttpclient 发送get请求，线程不会阻塞，程序往下走。

