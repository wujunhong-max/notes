# 动态库和静态库的区别

> 静态库：即静态链接库。以.a 为文件后缀名。在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库。

> 动态库：即动态链接库。以.tbd(之前叫.dylib)  为文件后缀名。在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在

> 区别：静态库代码装载的速度快，执行速度略比动态库快。但是动态库更加节省内存，可执行文件体积比静态库小很多。静态库是在编译时加载，动态库是在运行时加载

将一个C语言程序编译为动态链接库。

Windows下动态链接库的扩展名是dll，Linux下是so，Mac OS X 下是dylib

# PID和PPID

# 共享网络

## 查看ip

> ipconfig		--Windows下

## 查看共享那边的ip

>  arp -a

# 运行C++文件

> g++ .\hello.cpp
>
> .\a  或 a.exe
>
> 输入Ctrl + z 终止程序

## 命名问题

如果想命名为test.exe只需g++ -o test demo.cpp即可

## 自动输入测试数据

运行程序仍可以用demo.exe命令，但是此时还得一条一条的输入测试数据

但为了方便，可以将测试数据事先保存在文本文件（假设为input.txt）里面，

运行的时候直接往里面读取数据即可，注意的是input.txt里面的数据格式要按照demo.exe规定的格式

然后将结果写入另外一个文本文件（假设为output.txt）中，直接查看

使用`demo.exe <input.txt> output.txt即可完成以上操作`

# VS code 插件

## Bookmarks

创建和管理书签，看到哪个位置想加个书签就按Ctrl+Alt+K，多按一次就是删除，还可以在书签之前跳跃和查看管理

## TODO Tree

组织和管理TODO注释，在代码中注释的带TODO的标签会统一在侧边框显示出来，当然不限于TODO注释，可以自定义管理标签比如FIXME等，可以基于标签过滤和筛选

# 序列化

- 序列化就是将对象序列化为**二进制形式**（字节数组），一般也将序列化称为**编码**（Encode），主要用于网络传输、数据持久化等；
- 反序列化（deserialization）则是将从网络、磁盘等读取的字节数组还原成原始对象，以便后续业务的进行，一般也将反序列化称为**解码**（Decode），主要用于网络传输对象的解码，以便完成远程调用。

## **影响序列化性能的关键因素**

- 序列化后的码流大小（网络带宽的占用）；
- 序列化的性能（CPU资源占用）；
- 是否支持跨语言（异构系统的对接和开发语言切换）

## **Protobuf**

它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。

优点：

- 序列化后码流小，性能高
- 结构化数据存储格式（XML JSON等）
- 通过标识字段的顺序，可以实现协议的前向兼容
- 结构化的文档更容易管理和维护

缺点

- 需要依赖于工具生成代码
- 支持的语言相对较少，官方只支持Java 、C++ 、Python

适用场景

- 对性能要求高的RPC调用
- 具有良好的跨防火墙的访问属性
- 适合应用层对象的持久化

# .c和.cpp文件区别

一、指代不同

1、.c：表示C的源程序。

2、.cpp：表示C++的源程序。

二、变量声明不同

1、.c：c中变量声明和代码是分开的，必须在函数开始处声明。

2、.cpp：c++变量可以在任意处声明，只要保证先声明后使用就行。

三、指针类型不同

1、.c：void指针可以给任意类型指针赋值。

2、.cpp：必须先进行强制数据类型转换再赋值。

# 127.0.0.1

127.0.0.1是[回送地址](https://baike.baidu.com/item/回送地址/8021522)，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address），即[主机](https://baike.baidu.com/item/主机/455151)IP[堆栈](https://baike.baidu.com/item/堆栈/1682032)内部的[IP地址](https://baike.baidu.com/item/IP地址/150859)，主要用于网络软件测试以及本地机[进程间通信](https://baike.baidu.com/item/进程间通信/1235923)，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。

# 在Windows解压文件夹后，拉到linux环境，运行脚本出错

-bash: ./picom.sh: /bin/bash^M: bad interpreter: No such file or directory

出现了^M的脏东西

解决方法：sed -i "s/\r//" a.sh

# CPU是中央处理器