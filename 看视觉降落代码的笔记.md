# 看视觉降落代码的笔记



## 创建一个线程

pthread_create是UNIX环境创建线程函数
**头文件**
　　#include<pthread.h>
**函数声明**
　　int pthread_create(pthread_t*restrict tidp,const pthread_attr_t *restrict_attr,void*（*start_rtn)(void*),void *restrict arg);
**返回值**
　　若成功则返回0，否则返回出错编号
　　返回成功时，由tidp指向的内存单元被设置为新创建线程的线程ID。attr参数用于制定各种不同的线程属性。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个万能指针参数arg，如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入。
　　linux下用C开发多线程程序，Linux系统下的多线程遵循POSIX线程接口，称为pthread。
　　由 restrict 修饰的指针是最初唯一对指针所指向的对象进行存取的方法，仅当第二个指针基于第一个时，才能对对象进行存取。对对象的存取都限定于基于由 restrict 修饰的指针表达式中。 由 restrict 修饰的指针主要用于函数形参，或指向由 malloc() 分配的内存空间。restrict 数据类型不改变程序的语义。 编译器能通过作出 restrict 修饰的指针是存取对象的唯一方法的假设，更好地优化某些类型的例程。
**参数**
　　第一个参数为指向线程标识符的指针。
　　第二个参数用来设置线程属性。
　　第三个参数是线程运行函数的起始地址。
　　最后一个参数是运行函数的参数。

　　另外，在编译时注意加上-lpthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库$ 

```c++
gcc main.c -lpthread
$ ./a.out
```

## include<assert.h>

assert.h是c标准库的一个头文件，该头文件的主要目的就是提供一个assert的宏定义。

 assert只是对所给的表达式求值，就像if判断语句中一样，然后如果该值为真则正常运行，否则报错，并调用abort(),产生异常中断，exit出来。适用于软件测试、调试、排错

 该宏可以屏蔽掉，只需在包含assert.h之前＃define NDEBUG，想开再#undef。从这里可以看出预处理带来的方便。

```c
#define NDEBUG//关闭静态断言，必须放在头文件上方
```

**函数名：assert**

功能：测试一个条件并可能使程序终止

用 法: void assert(int test);

malloc分配内存失败，返回NULL，assert可以用于检测指针是否NULL

缺点：频繁的调用会极大的影响程序的性能，增加额外的开销

## telnet

> telnet ip地址 端口



## netstat -nt | grep 端口

## #define、#undef、#ifdef、#ifndef、#if、#elif、#else、#endif、defined

c语言中条件编译相关的预编译指令，包括 *#define、#undef、#ifdef、#ifndef、#if、#elif、#else、#endif、defined。*

```bash
#define       定义一个预处理宏
#undef       取消宏的定义

#if          编译预处理中的条件命令，相当于C语法中的if语句
#ifdef        判断某个宏是否被定义，若已定义，执行随后的语句
#ifndef       与#ifdef相反，判断某个宏是否未被定义
#elif         若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if
#else        与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else
#endif       #if, #ifdef, #ifndef这些条件命令的结束标志.
defined     　与#if, #elif配合使用，判断某个宏是否被定义
```

以#开头的都是预编译指令，就是在正式编译之前，编译器做一些预处理的工作

```bash
#if 条件语句
程序段1  //如果条件语句成立，那么就编译程序段1  
#endif
程序段2//如果条件不语句成立，那么就编译程序段2 

#ifndef x//先测试x是否被宏定义过  
#define   程序段1 //如果x没有被宏定义过，那么就编译程序段1   
#endif  
程序段2 //如果x已经定义过了则编译程序段2的语句，“忽视”程序段1。 

#ifdef x  //先测试x是否被宏定义过  
程序段1   //如果x被宏定义过，那么就编译程序段1  
#endif 
程序段2 //如果x没有被定义过则编译程序段2的语句，“忽视”程序段1。 

if就是判断语句，不是预编译指令
```

## signal()函数

### 定义

设置一个函数来处理信号，即带有 **sig** 参数的信号处理程序

### 声明

> ```c++
> void (*signal(int sig, void (*func)(int)))(int)
> ```

### 参数

- sig -- 在信号处理程序中作为变量使用的信号码。下面是一些重要的标准信号常量

| 宏      | 信号                                                         |
| ------- | ------------------------------------------------------------ |
| SIGABRT | (Signal Abort) 程序异常终止。                                |
| SIGFPE  | (Signal Floating-Point Exception) 算术运算出错，如除数为 0 或溢出（不一定是浮点运算）。 |
| SIGILL  | (Signal Illegal Instruction) 非法函数映象，如非法指令，通常是由于代码中的某个变体或者尝试执行数据导致的。 |
| SIGINT  | (Signal Interrupt) 中断信号，如 ctrl-C，通常由用户生成。     |
| SIGSEGV | (Signal Segmentation Violation) 非法访问存储器，如访问不存在的内存单元。 |
| SIGTERM | (Signal Terminate) 发送给本程序的终止请求信号。              |

- **func**  -- 一个指向函数的指针。它可以是一个由程序定义的函数，也可以是下面预定义函数之一：

| SIG_DFL | 默认的信号处理程序。 |
| ------- | -------------------- |
| SIG_IGN | 忽视信号。           |

### 返回值

该函数返回信号处理程序之前的值，当发生错误时返回 SIG_ERR。

## Opencv -- waitKey()

函数格式：

```c++
int waitKey（int delay=0） 

delay-延时的时间，单位ms；
```

作用：在显示图像时具有延时的作用

参数x    ：等待x ms，如果在x ms期间，按下任意键，则立刻结束并返回按下键的ASCll码，否则返回-1

​				如果设置waitKey(0),则表示程序会无限制的等待用户的按键事件 

 waitKey函数的窗口机制：	waitKey的延时功能主要针对图像窗口机制的；

​                                              没有窗口，则waitKey命令不执行；

​                                             纯粹的延时用sleep命令；

## GaussianBlur函数

作用：对图像进行高斯滤波，去除噪声，图像预处理一般都用

 用高斯滤波器（GaussianFilter）对图像进行平滑处理。 
 该函数将源图像与指定的高斯内核进行卷积，同时也支持in-place滤波。

调用形式：

```c++
void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT )
    
InputArray src：输入的图像

OutputArray dst：输出图像

Size ksize：高斯卷积核的大小，是奇数

double sigmaX, double sigmaY=0, ：表示x和y方向的方差，如果y=0则y方向的方差与x相等

int borderType=BORDER_DEFAULT ：边界的处理方式，一般默认
```

## cvtColor()

作用：用于实现图像的色彩空间转换

函数格式：cvtColor(src,dst,type,channels)； 即源图像，目标图像，转换方式，目标图像通道数

## Mat数据类型

Mat类型是opencv2.0后的类型，使用此类型无需进行内存管理，即无需手动分配内存，在不需要时自动释放内存

Mat包含2个**数据部分**：the matrix header--包含matrix大小，存储方法，matrix存储地址等，matrix header内存大小固定；

​                 指向像素matrix的指针。

OpenCV使用的是引用计数系统：每个Mat对象都有着自己的header，但matrix可在两个实例中通过指向同一个matrix首地址的指针来共享数据。拷贝构造和赋值均只拷贝其header和指向matrix的指针，而非像素数据的本身。当拷贝一个Mat对象的header时，关于matrix的计数器数值增加，一旦header被清理了，counter减少，当counter减少到0的时候，matrix的内存空间会被释放

OpenCV提供了**clone（）和copyto（）**两函数来拷贝matrix数据本身

## \#pragma omp parallel for

\#pragma omp parallel for是OpenMP中的一个指令，表示接下来的for循环将被多线程执行，另外每次循环之间不能有关系

```c++
int main(int argc, char* argv[])
{
#pragma omp parallel for  //后面是for循环
     for (int i = 0; i < 10; i++ )
     {
         printf("i = %d/n", i);
     }
     return 0;
}
这个程序执行后打印出以下结果：
i = 0
i = 5
i = 1
i = 6
i = 2
i = 7
i = 3
i = 8
i = 4
i = 9
```

for循环里的内容必须满足可以并行执行，即每次循环互不相干，后一次循环不依赖于前面的循环
# 交叉编译

因为在树莓派的opencv库是arm，服务器上的是x86-64，在树莓派上没找到静态库，而用服务器上的opencv库环境运行不了。

交叉编译生成了在服务器上的opencv静态库。

用opencv写的程序在树莓派上能编译后运行，

但在服务器上编译后，拉到树莓派上运行后，摄像头设备打不开

后来用v4l2能打开摄像头，得重写代码
