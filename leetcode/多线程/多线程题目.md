# C多线程题目

## 1114.按序打印

![8191cafa1d1683cc9e3c5b42ec09d79](photo/8191cafa1d1683cc9e3c5b42ec09d79.png)

![9c7a5b6820e2ef021915f2b962d75c4](photo/9c7a5b6820e2ef021915f2b962d75c4.png)

### 解决代码

```c++
#include<pthread.h>
#include<semaphore.h>
using namespace std;

class Foo {
public:
    Foo() {
        sem_init(&sem1, 0, 0);
        sem_init(&sem2, 0, 0);
    }

    void first(function<void()> printFirst) {
     
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        sem_post(&sem1);
    }

    void second(function<void()> printSecond) {
        sem_wait(&sem1);
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        sem_post(&sem2);
    }

    void third(function<void()> printThird) {
        sem_wait(&sem2);
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
private:
    sem_t sem1;
    sem_t sem2;
};
```

### 总结

> 使用了两个信号量来模拟条件变量，使能够按序打印

## 1115. 交替打印FooBar

![cf0b5ffa77c84a09dc91583276c9a29](photo/cf0b5ffa77c84a09dc91583276c9a29.png)

![4640236e40541965db50b36417dcbcd](photo/4640236e40541965db50b36417dcbcd.png)

### 解决代码

```c++
#include<pthread.h>
#include<time.h>
#include<pthread.h>
#include<semaphore.h>
using namespace std;

class FooBar {
private:
    int n;
    sem_t sem1;
    sem_t sem2;

public:
    FooBar(int n) {
        this->n = n;
        sem_init(&sem1, 0, 0);
        sem_init(&sem2, 0, 0);
        sem_post(&sem1);
    }

    void foo(function<void()> printFoo) {
        
        for (int i = 0; i < n; i++) {
            sem_wait(&sem1);
        	// printFoo() outputs "foo". Do not change or remove this line.
        	printFoo();
            sem_post(&sem2);
        }
    }

    void bar(function<void()> printBar) {
        
        for (int i = 0; i < n; i++) {
           sem_wait(&sem2);
        	// printBar() outputs "bar". Do not change or remove this line.
        	printBar();
           sem_post(&sem1);
        }
    }
};
```

### 总结

> 用两个信号量，要交替打印，让两个线程分别生产对方的信号量，这样就能交替执行

## 1116.打印零与奇偶数

![6371af0b3aa56860b626a2202ef355f](photo/6371af0b3aa56860b626a2202ef355f.png)

![0914565a4e845b53d37045cfa3be2cf](photo/0914565a4e845b53d37045cfa3be2cf.png)

### 解决代码

```c++
#include<semaphore.h>
class ZeroEvenOdd {
private:
    int n;
    sem_t zero_sem;
    sem_t odd_sem;
    sem_t even_sem;

public:
    ZeroEvenOdd(int n) {
        this->n = n;
        sem_init(&zero_sem, 0, 1);
        sem_init(&odd_sem, 0, 0);
        sem_init(&even_sem, 0, 0);
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        for(int i=1; i<=n; i++)
        {
            sem_wait(&zero_sem);
             printNumber(0);
             if(i%2 == 0)
             {
                 sem_post(&even_sem);  
             } 
             else 
             {
                 sem_post(&odd_sem);
             }
             
        }
    }

    void even(function<void(int)> printNumber) {
        for(int j=2; j<=n; j=j+2)
        {
            sem_wait(&even_sem);
            printNumber(j);
            sem_post(&zero_sem);
        }
    }

    void odd(function<void(int)> printNumber) {
        for(int z=1; z<=n; z=z+2)
        {
             sem_wait(&odd_sem);
             printNumber(z);
             sem_post(&zero_sem);
        }
    }
};
```

### 总结

> LeetCode底层实现时,
>
> zero中printNumber.accept只能输入0,
>
> even中printNumber.accept只能输入偶数,
>
> odd中printNumber.accept只能输入奇数,

## 1117. H2O生成

![8359d917a4a0ff86a9931e6bfcc0e45](photo/8359d917a4a0ff86a9931e6bfcc0e45.png)

![bb3de3f447247728f8bb91c97adf744](photo/bb3de3f447247728f8bb91c97adf744.png)

### 解决代码

```c++
#include<semaphore.h>

class H2O {
private:
    sem_t sem1;
    sem_t sem2;
    int i=0;
public:
    H2O() {
        sem_init(&sem1, 0, 0);
        sem_init(&sem2, 0, 1);
    }

    void hydrogen(function<void()> releaseHydrogen) {
        sem_wait(&sem1);
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();
        i++;
        if(i==2)
        {
            i=0;
            sem_post(&sem2);
        }
    }

    void oxygen(function<void()> releaseOxygen) {
        sem_wait(&sem2);
        sem_post(&sem1);
        sem_post(&sem1);
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
    }
};
```

### 总结

> 用两个信号量，当一个线程中的函数运行了两次，满足条件后就激活另一个线程。

## 1195. 交替打印字符串

![b5ddc983495284a0f887d753f635e7e](photo/b5ddc983495284a0f887d753f635e7e.png)

### 解决代码

```c++
#include<semaphore.h>

class FizzBuzz {
private:
    int n;
    sem_t fizz_sem;
    sem_t buzz_sem;
    sem_t fizzbuzz_sem;
    sem_t number_sem;
public:
    FizzBuzz(int n) {
        this->n = n;
        sem_init(&fizz_sem, 0, 1);
        sem_init(&buzz_sem, 0, 0);
        sem_init(&fizzbuzz_sem, 0, 0);
        sem_init(&number_sem, 0, 0);
    }

    // printFizz() outputs "fizz".
    void fizz(function<void()> printFizz) {
        for(int i=1; i<=n; i++)
        {
            sem_wait(&fizz_sem);
            if(i%3 == 0 && i%5 != 0)    printFizz();
            sem_post(&buzz_sem);
        }
    }

    // printBuzz() outputs "buzz".
    void buzz(function<void()> printBuzz) {
          for(int i=1; i<=n; i++)
        {
            sem_wait(&buzz_sem);
            if(i%3 != 0 && i%5 == 0)    printBuzz();
            sem_post(&fizzbuzz_sem);
        }
    }

    // printFizzBuzz() outputs "fizzbuzz".
	void fizzbuzz(function<void()> printFizzBuzz) {
          for(int i=1; i<=n; i++)
        {
            sem_wait(&fizzbuzz_sem);
            if(i%3 == 0 && i%5 == 0)    printFizzBuzz();
            sem_post(&number_sem);
        }
    }

    // printNumber(x) outputs "x", where x is an integer.
    void number(function<void(int)> printNumber) {
         for(int i=1; i<=n; i++)
        {
            sem_wait(&number_sem);
            if(i%3 != 0 && i%5 != 0)    printNumber(i);
            sem_post(&fizz_sem);
        }
    }
};
```

### 总结

> 用4个信号量来控制线程的顺序

## 1226. 哲学家进餐（死锁经典问题)

![46486c1bb236d2771d3ee1c5e679fcb](photo/46486c1bb236d2771d3ee1c5e679fcb.png)

<img src="photo/c2a34b51730106d2ed5ee0068636b6b.png" alt="c2a34b51730106d2ed5ee0068636b6b" style="zoom: 67%;" />

![4c5dc57b603b9b81a24867451425faa](photo/4c5dc57b603b9b81a24867451425faa.png)

![fea36eb2596132de70b3870a2c39b5e](photo/fea36eb2596132de70b3870a2c39b5e.png)

### 求解方法

问题的本质就是解决N个哲学家同时就餐时的死锁问题，解题思路如下：

1.使用and语义，即要么多锁同时被锁定，要么全部不被锁定。
2.限定就餐人数为N-1，这样死锁的闭环总不成立。
3.奇偶编号的哲学家加锁顺序不一致即可。
4.只有一个人拿筷子的顺序和其他人不一样也可以避免一个闭环。

**策略1：**

**只有当哲学家的左右两只筷子均处于可用状态时**，才允许他拿起筷子。这样就可以避免他们同时拿起筷子就餐，导致死锁

1.当得不到所有所需资源时，放弃已经获得的资源，等待。

2.保证资源的获取顺序，要求每个线程获取资源的顺序一致。



**策略2:**

**至多允许有四位哲学家**同时去竞争就餐，最终可以保证至少有一位哲学家成功就餐，并在就餐完毕，释放他的筷子资源，其他的philosopher就有机会可以就餐了

```c++
// 伪代码
semaphore chopstick[5] = [1,1,1,1,1];
semaphore count = 4; // 设置一个count,最多有4个哲学家可以进来
void philosopher(int i)
{
	while(true)
	{
		think();  // 思考
		P(count); // 请求进入房间进餐，当count为0时，不能允许哲学家再进来了
		
		P(chopstick[i]); // 请求左手边的筷子
		P(chopstick[(i+1)%5]); // 请求右手边的筷子
		eat();
		V(chopstick[i]); // 释放左手边的筷子
		V(chopstick[(i+1)%5]); // 释放右手边的筷子
		
		V(count); // 离开饭桌释放信号量
	}
}
```

**策略3：**

利用封装好的信号量，使用奇偶法。防止哲学家饿死的情况，制定如下规则：

规则： 奇数号的哲学家先拿起右边的筷子再拿起左边的筷子。

​			偶数号哲学家先拿起左边的筷子，再拿起右边的筷子。

如果哲学家抢到一只筷子，在抢占另一只筷子时失败，则要放弃已经抢占到的资源。

左右两边都抢到筷子的哲学家，吃完放后释放资源。

实现时只需在求解策略二的基础上加个奇偶判断就可以了


### 解决代码

```c++
class DiningPhilosophers {
private:
    pthread_mutex_t forks[5];
public:
    DiningPhilosophers() {
        for(int i = 0; i < 5; i++) pthread_mutex_init(forks + i, NULL);
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int left_hand = philosopher, right_hand = (philosopher + 1) % 5;    //左右手序号
        int ret1 = 1, ret2 = 1;
        while(ret1 != 0 || ret2 != 0) {                                               //尝试同时锁两个直到成功
            if(ret1 == 0) pthread_mutex_unlock(forks + left_hand);          //锁失败锁住的打开
            if(ret2 == 0) pthread_mutex_unlock(forks + right_hand);
            ret1 = pthread_mutex_trylock(forks + left_hand);                //继续尝试 
            ret2 = pthread_mutex_trylock(forks + right_hand);               //pthread_mutex_trylock 成功会返回0
        }
        pickLeftFork();
        pickRightFork();
        eat();
        putLeftFork();
        putRightFork();
        pthread_mutex_unlock(forks + left_hand);                            //全部解锁
        pthread_mutex_unlock(forks + right_hand);
    }
};
```

