# 前提

排序函数命名规范

> void X_sort( ElementType A[ ], int N )

- N是正整数
- 只讨论基于比较的排序( > = < 有定义)
- 只讨论内部排序
- 稳定性：任意两个相等的数据，排序前后的相对位置不发生改变
- 没有一种排序是任何情况下都表现最好的

# 简单排序(冒泡、插入)

## 冒泡排序

![1628481075582](img/1628481075582.png)

每次从上到下比较相邻的两个泡泡，大的泡泡往下走（交换位置)，这样在最下面的泡泡就是最大的。

```C++
void bubble_sort( int A[], int N)
{
     for(int i=N-1; i>0; i--) /* 只需要找出N-1个泡泡就行 */
     {
         int flag = 0;
         for(int j=0; j<i; j++) /* 一趟冒泡 */
         {
             if(A[j] > A[j+1])
             {
                 swap(A[j], A[j+1]);
                 flag = 1;
             }
         }
         if(flag == 0) break;  /* 全程无交换 */
     }
}
```

### 时间复杂度

最好情况： 数组本身是顺序的，外层循环遍历一次就完成了      T=O(N)

最坏情况：数组本身是逆序的，内外层遍历                                T=O (N^2)

交换次数最多是：(n-1)!

### 空间复杂度

开辟一个空间交换顺序 O(1)

### 稳定性

稳定

### 测试题

1.对于7个数进行冒泡排序，最坏情况下需要进行的比较次数为（）

正确答案：6! = 1+2+3+4+5+6 = 21;

## 插入排序

![1628490587280](img/1628490587280.png)

插入排序：插入一张牌，后面的牌要往后移一位

```c++
void insertion_sort( int A[], int N)
{
    for( int i=1; i<N; i++) /* 不用从0开始，默认手中有一张牌 */
    {
        int Temp = A[i];  /* 摸下一张牌 */
        for( int j=i; j>0 && A[j-1]>Temp; j--)
        {
            A[j] = A[j-1]; /* 移出空位 */
            A[j-1] = Temp;
        }
       
    }
}
```

### 时间复杂度

最好情况： 顺序 T=O(N)

最坏情况 ：逆序 T=O(N^2) 

### 测试题

 对一组包含10个元素的非递减有序序列，采用插入排序排成非递增序列，其可能的比较次数和移动次数分别是 

A. 45,44                        B.54,63                        C.100,54                        D.100,100

答案是A；

最坏情况下移动次数是 9！=1+2+3+4+5+6+7+8+9 = 45， 因为题目中有可能两字，所以可以有相等的数，故可以选择A
