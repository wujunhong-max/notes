# 多线程编程

## 定义

**线程**是操作系统能够进行运算调度的最小单位，它被包含在**进程**之中，是**进程**中的实际运作单位。

**多线程**就是指从软件或者硬件上实现**多个线程并发执行**的技术。

多线程是为了**同步完成多项任务**，不是为了提高运行效率，而是为了**提高资源使用效率**来提高系统的效率。多线程是在同一时间需要完成多项任务的时间实现的。

## 优点

1. **加快程序的运行速度，使程序的响应速度更快**，因为用户界面可以在进行其它工作的同时一直处于活动状态
2. 可以把占据长时间的程序中的任务**放到后台去处理**，**同时执行其它操作**，提高效率
3. 当前没有处理的任务时可以将处理器时间让给其它任务
4. 可以让同一个程序的不同部分并发执行，**释放一些珍贵的资源如内存占用**等等
5. 可以**随时停止任务**
6. 可以分别设置各个任务的**优先级以优化性能**

## 缺点

1. 因为多线程**需要开辟内存**，而且线程切换**需要时间**。因此会很消耗系统内存
2. 线程的终止会对程序产生影响
3. 由于多个线程之间存在**共享数据**，因此**容易出现线程死锁**的情况
4. 对线程进行管理要求**额外的CPU开销**。线程的使用会给系统带来上下文切换的额外负担

## 同步与互斥的概念

### 同步

指散布在不同任务之间的若干程序片段，它们的运行**必须严格**按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：**两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如A任务的运行依赖于B任务产生的数据**

### 互斥

是指散布在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完整个程序片段后才可以运行。最基本的场景就是：**一个公共资源同一时刻只能被提高进程或线程使用，多个线程或进程不能同时使用公共资源**

## 互斥锁(同步)

互斥锁是一种简单的加锁的方法来**控制对共享资源的访问**，互斥锁只有两种状态，即**上锁(lock)和解锁(unlock)**

**互斥锁的特点**

## 读写锁(同步)

读写锁与互斥量类似，不过读写锁允许更改的并行性，**也叫共享互斥锁**。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。

读写锁可以有3种状态：**读模式下加锁状态**、**写模式加锁状态**、**不加锁状态**

**一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）。**

### 特点

- 如果有其他线程读数据，则允许其它线程执行读操作，但不允许写操作

  （允许多位读者同时访问某数据)

- 如果有其他线程写数据，则其他线程都不允许读、写操作

### 规则

- 如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁
- 如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁

读写锁适合于对数据结构的读次数比写次数多得多的情况

```c++
#include <pthread.h>
// 初始化读写锁
int pthread_rwlock_init(pthread_rwlock_t *rwlock, 
						const pthread_rwlockattr_t *attr); 

// 申请读锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock ); 

// 申请写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock ); 

// 尝试以非阻塞的方式来在读写锁上获取写锁，
// 如果有任何的读者或写者持有该锁，则立即失败返回。
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 

// 解锁
int pthread_rwlock_unlock (pthread_rwlock_t *rwlock); 

// 销毁读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

### Demo

```c++
// 一个使用读写锁来实现 4 个线程读写一段数据是实例。
// 在此示例程序中，共创建了 4 个线程，
// 其中两个线程用来写入数据，两个线程用来读取数据
#include <stdio.h>  
#include <unistd.h>  
#include <pthread.h>  

pthread_rwlock_t rwlock; //读写锁  
int num = 1;  
  
//读操作，其他线程允许读操作，却不允许写操作  
void *fun1(void *arg)  
{  
    while(1)  
    {  
        pthread_rwlock_rdlock(&rwlock);
        printf("read num first == %d\n", num);
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
  
//读操作，其他线程允许读操作，却不允许写操作  
void *fun2(void *arg)
{
    while(1)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("read num second == %d\n", num);
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
 
//写操作，其它线程都不允许读或写操作  
void *fun3(void *arg)
{
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);
        num++;
        printf("write thread first\n");
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
 
//写操作，其它线程都不允许读或写操作  
void *fun4(void *arg)
{
    while(1)
    {  
        pthread_rwlock_wrlock(&rwlock);  
        num++;  
        printf("write thread second\n");  
        pthread_rwlock_unlock(&rwlock);  
        sleep(2);  
    }  
}  
  
int main()  
{  
    pthread_t ptd1, ptd2, ptd3, ptd4;  
      
    pthread_rwlock_init(&rwlock, NULL);//初始化一个读写锁  
      
    //创建线程  
    pthread_create(&ptd1, NULL, fun1, NULL);  
    pthread_create(&ptd2, NULL, fun2, NULL);  
    pthread_create(&ptd3, NULL, fun3, NULL);  
    pthread_create(&ptd4, NULL, fun4, NULL);  
      
    //等待线程结束，回收其资源  
    pthread_join(ptd1, NULL);  
    pthread_join(ptd2, NULL);  
    pthread_join(ptd3, NULL);  
    pthread_join(ptd4, NULL);  
      
    pthread_rwlock_destroy(&rwlock);//销毁读写锁  
      
    return 0;  
}  
```

如果没解锁，就会阻塞住。

