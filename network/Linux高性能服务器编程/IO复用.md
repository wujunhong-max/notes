

# I/O复用模型

select, poll, epoll

## I/O操作

我们都知道unix(like)世界里，一切皆文件。而文件就是一串**二进制流**而已，不管是socket,还是FIFO(先进先出队列)、管道、终端, 对我们来说，一切都是文件，一切都是流。我们对这些流进行数据的收发操作，简称为**I/O操作(input and output)**          往流中读出数据，系统调用read，写入数据，系统调用write.

## 阻塞和非阻塞忙轮询

什么是程序的阻塞呢？想象这种情形，比如你等快递，但快递一直没来，你会怎么做？有两种方式：

- 快递没来，我可以先去睡觉，然后快递来了给我打电话叫我去取就行了。
- 快递没来，我就不停的给快递打电话说：擦，怎么还没来，给老子快点，直到快递来。

在计算机世界，这两种情形就对应**阻塞和非阻塞忙轮询**

- 阻塞：数据没来，啥都不做，直到数据来了，才进行下一步的处理。
- 非阻塞忙轮询：数据没来，进程就不停的去检测数据，直到数据来。

**因为一个线程只能处理一个套接字的I/O事件，如果想同时处理多个，可以利用非阻塞忙轮询的方式**

## 引入中间层

我们只要把所有流从头到尾查询一遍，就可以处理多个流了，但这样做很不好，因为如果所有的流都没有I/O事件，白白浪费CPU时间片。我们增加了一个**中间层**来解决。

同样，为了避免这里cpu的空转，我们不让这个线程亲自去检查流中是否有事件，而是引进了一个代理(一开始是select,后来是poll)，这个代理很牛，它可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个挨个去轮询了。

- select只是告诉你一定数目的流有事件了,至于哪个流有事件，还得你一个一个地去轮询,select具有O(n)的无差别轮询复杂度
- epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到哪个流了。epoll实际上是**事件驱动（每个事件关联上fd）**,复杂度降低到了O(1)

## I/O多路复用



### 阻塞I/O模型

### 非阻塞I/O模型

### I/O复用模型

## poll

### 函数原型

```c
#include<poll.h>

int poll(struct pollfd *fds, nfd_s nfds, int timeout)
```

```c
struct pollfd{

int fd;      /* file fescriptor */
short events;   /* requested events */
short revents;  /* returned events */

}
```

