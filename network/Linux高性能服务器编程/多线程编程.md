# 多线程编程

## 定义

**线程**是操作系统能够进行运算调度的最小单位，它被包含在**进程**之中，是**进程**中的实际运作单位。

**多线程**就是指从软件或者硬件上实现**多个线程并发执行**的技术。

多线程是为了**同步完成多项任务**，不是为了提高运行效率，而是为了**提高资源使用效率**来提高系统的效率。多线程是在同一时间需要完成多项任务的时间实现的。

和多进程相比，多线程是一种比较**节省资源**的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进程间通信的方式进行。可以运行多个线程，运行于同一个进程中的多个线程，**它们彼此之间使用相同的地址空间，共享全局变量和对象，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。**

## 优点

1. **加快程序的运行速度，使程序的响应速度更快**，因为用户界面可以在进行其它工作的同时一直处于活动状态
2. 可以把占据长时间的程序中的任务**放到后台去处理**，**同时执行其它操作**，提高效率
3. 当前没有处理的任务时可以将处理器时间让给其它任务
4. 可以让同一个程序的不同部分并发执行，**释放一些珍贵的资源如内存占用**等等
5. 可以**随时停止任务**
6. 可以分别设置各个任务的**优先级以优化性能**

## 缺点

1. 因为多线程**需要开辟内存**，而且线程切换**需要时间**。因此会很消耗系统内存
2. 线程的终止会对程序产生影响
3. 由于多个线程之间存在**共享数据**，因此**容易出现线程死锁**的情况
4. 对线程进行管理要求**额外的CPU开销**。线程的使用会给系统带来上下文切换的额外负担

# 同步与互斥的概念

### 同步

指散布在不同任务之间的若干程序片段，它们的运行**必须严格**按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：**两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如A任务的运行依赖于B任务产生的数据**

### 互斥

是指散布在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完整个程序片段后才可以运行。最基本的场景就是：**一个公共资源同一时刻只能被提高进程或线程使用，多个线程或进程不能同时使用公共资源**

# 线程同步

对多线程来说，**资源是共享的**，基本上不存在不允许访问的情况，但是，共享的资源**在某一时间点只能有一个线程占用**，所以需要给资源加锁

线程锁的种类有**互斥锁、读写锁、条件变量、自旋锁、信号灯**

## 互斥锁(同步)

互斥锁是一种简单的加锁的方法来**控制对共享资源的访问**，互斥锁只有两种状态，即**上锁(lock)和解锁(unlock)**

### 1.初始化锁

```c++
int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutex_attr_t *mutexattr);
```

其中参数 mutexattr 用于指定锁的属性（见下），如果为NULL则使用缺省属性。

互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：

1）PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。

2）PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。

3）PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。

4）PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，等待解锁后重新竞争。

### 2.阻塞加锁

```c++
int pthread_mutex_lock(pthread_mutex *mutex);
```

如果是锁是空闲状态，本线程将获得这个锁；如果锁已经被占据，本线程将排队等待，直到成功的获取锁。

### 3.非阻塞加锁

```c++
int pthread_mutex_trylock( pthread_mutex_t *mutex);
```

该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回 EBUSY，不是挂起等待。

### 4.解锁

```c++
int pthread_mutex_unlock(pthread_mutex *mutex);
```

线程把自己持有的锁释放。

### 5.销毁锁（此时锁必需unlock状态，否则返回EBUSY）

```c++
int pthread_mutex_destroy(pthread_mutex *mutex);
```

销毁锁之前，锁必需是空闲状态（unlock）

### 示例程序

```c++
// 使用互斥量解决多线程抢占资源的问题

// g++ duoxc.cpp -o duoxc -lpthread
// ./duoxc
// 当一个线程上锁后，其他线程会阻塞住，等待该线程解锁，之后其他线程才能上锁
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>
#include<time.h>
#include<string.h>
using namespace std;

char buffer[101];   // 全局共享的buffer
//声明互斥锁，实际上只是把互斥锁的每个字段都初始化为0
// pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 
pthread_mutex_t mutex; //声明互斥锁

void *pthfun(void *arg)
{
    for(int i=0; i<3; i++)
    {
        time_t current = time(NULL);
        tm* p = localtime(&current);
         printf("%d年%02d月%02d日 %02d时%02d分%02d秒:%ld：lock...\n",p->tm_year+1900,p->tm_mon+1,p->tm_mday,p->tm_hour,p->tm_min,p->tm_sec,(long)arg);
        pthread_mutex_lock(&mutex);   // 加锁
        printf("%d年%02d月%02d日 %02d时%02d分%02d秒:%ld：lock ok\n",p->tm_year+1900,p->tm_mon+1,p->tm_mday,p->tm_hour,p->tm_min,p->tm_sec,(long)arg);

        // 操作共享的全局变量
        sprintf(buffer,"%d年%02d月%02d日 %02d时%02d分%02d秒:%ld,%d",p->tm_year+1900,p->tm_mon+1,p->tm_mday,p->tm_hour,p->tm_min,p->tm_sec,pthread_self(),i);
        sleep(5);

        pthread_mutex_unlock(&mutex);  // 解锁
        printf("%d年%02d月%02d日 %02d时%02d分%02d秒:%ld:unlock...\n",p->tm_year+1900,p->tm_mon+1,p->tm_mday,p->tm_hour,p->tm_min,p->tm_sec+5,(long)arg);
        usleep(100);
    }
}

int main()
{
    pthread_mutex_init(&mutex,NULL); // 初始化锁
    pthread_t pthid1,pthid2;    // 创建两个线程的标识符
    pthread_create(&pthid1, NULL, pthfun, (void *)1);   // 创建线程
    pthread_create(&pthid2, NULL, pthfun, (void *)2);

    pthread_join(pthid1,NULL);  // 回收线程
    pthread_join(pthid2, NULL);
    
    pthread_mutex_destroy(&mutex); // 销毁锁，释放器占用的内核资源
    return 0;
}
```

运行结果：

![image-20210529203725067](photo/image-20210529203725067.png)

## 读写锁(同步)

读写锁与互斥量类似，不过读写锁允许更改的并行性，**也叫共享互斥锁**。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。

读写锁可以有3种状态：**读模式下加锁状态**、**写模式加锁状态**、**不加锁状态**

**一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）。**

### 特点

- 如果有其他线程读数据，则允许其它线程执行读操作，但不允许写操作

  （允许多位读者同时访问某数据)

- 如果有其他线程写数据，则其他线程都不允许读、写操作

### 规则

- 如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁
- 如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁

读写锁适合于对数据结构的读次数比写次数多得多的情况

```c++
#include <pthread.h>
// 初始化读写锁
int pthread_rwlock_init(pthread_rwlock_t *rwlock, 
						const pthread_rwlockattr_t *attr); 

// 申请读锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock ); 

// 申请写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock ); 

// 尝试以非阻塞的方式来在读写锁上获取写锁，
// 如果有任何的读者或写者持有该锁，则立即失败返回。
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 

// 解锁
int pthread_rwlock_unlock (pthread_rwlock_t *rwlock); 

// 销毁读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

### Demo

```c++
// 一个使用读写锁来实现 4 个线程读写一段数据是实例。
// 在此示例程序中，共创建了 4 个线程，
// 其中两个线程用来写入数据，两个线程用来读取数据
#include <stdio.h>  
#include <unistd.h>  
#include <pthread.h>  

pthread_rwlock_t rwlock; //声明读写锁  
int num = 1;  
  
//读操作，其他线程允许读操作，却不允许写操作  
void *fun1(void *arg)  
{  
    while(1)  
    {  
        pthread_rwlock_rdlock(&rwlock);
        printf("read num first == %d\n", num);
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
  
//读操作，其他线程允许读操作，却不允许写操作  
void *fun2(void *arg)
{
    while(1)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("read num second == %d\n", num);
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
 
//写操作，其它线程都不允许读或写操作  
void *fun3(void *arg)
{
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);
        num++;
        printf("write thread first\n");
        pthread_rwlock_unlock(&rwlock);
        sleep(2);
    }
}
 
//写操作，其它线程都不允许读或写操作  
void *fun4(void *arg)
{
    while(1)
    {  
        pthread_rwlock_wrlock(&rwlock);  
        num++;  
        printf("write thread second\n");  
        pthread_rwlock_unlock(&rwlock);  
        sleep(2);  
    }  
}  
  
int main()  
{  
    pthread_t ptd1, ptd2, ptd3, ptd4;  // 创建线程的
      
    pthread_rwlock_init(&rwlock, NULL);//初始化一个读写锁  
      
    //创建线程  
    pthread_create(&ptd1, NULL, fun1, NULL);  
    pthread_create(&ptd2, NULL, fun2, NULL);  
    pthread_create(&ptd3, NULL, fun3, NULL);  
    pthread_create(&ptd4, NULL, fun4, NULL);  
      
    //等待线程结束，回收其资源  
    pthread_join(ptd1, NULL);  
    pthread_join(ptd2, NULL);  
    pthread_join(ptd3, NULL);  
    pthread_join(ptd4, NULL);  
      
    pthread_rwlock_destroy(&rwlock);//销毁读写锁  
      
    return 0;  
}  
```

## 条件变量

